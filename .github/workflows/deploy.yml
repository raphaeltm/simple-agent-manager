name: Deploy

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      skip_agent:
        description: 'Skip VM Agent build and upload'
        required: false
        type: boolean
        default: false
      dry_run:
        description: 'Preview changes without applying'
        required: false
        type: boolean
        default: false

# Only one deployment at a time, queue subsequent ones
concurrency:
  group: deploy-production
  cancel-in-progress: false

env:
  NODE_VERSION: '22'
  GO_VERSION: '1.22'

jobs:
  # Validate required configuration exists before attempting deployment
  validate:
    name: Validate Configuration
    runs-on: ubuntu-latest
    environment: production
    outputs:
      config_valid: ${{ steps.check.outputs.valid }}
    steps:
      - name: Check Required Configuration
        id: check
        run: |
          MISSING=""

          # Check required environment variables
          if [ -z "${{ vars.BASE_DOMAIN }}" ]; then
            MISSING="$MISSING\n  - vars.BASE_DOMAIN"
          fi

          # Check required secrets (we can't read values, but we can check if they're set)
          # This is done by checking if the secret resolves to empty string
          if [ -z "${{ secrets.CF_API_TOKEN }}" ]; then
            MISSING="$MISSING\n  - secrets.CF_API_TOKEN"
          fi
          if [ -z "${{ secrets.CF_ACCOUNT_ID }}" ]; then
            MISSING="$MISSING\n  - secrets.CF_ACCOUNT_ID"
          fi
          if [ -z "${{ secrets.CF_ZONE_ID }}" ]; then
            MISSING="$MISSING\n  - secrets.CF_ZONE_ID"
          fi
          if [ -z "${{ secrets.R2_ACCESS_KEY_ID }}" ]; then
            MISSING="$MISSING\n  - secrets.R2_ACCESS_KEY_ID"
          fi
          if [ -z "${{ secrets.R2_SECRET_ACCESS_KEY }}" ]; then
            MISSING="$MISSING\n  - secrets.R2_SECRET_ACCESS_KEY"
          fi
          if [ -z "${{ secrets.PULUMI_CONFIG_PASSPHRASE }}" ]; then
            MISSING="$MISSING\n  - secrets.PULUMI_CONFIG_PASSPHRASE"
          fi
          if [ -z "${{ secrets.GH_CLIENT_ID }}" ]; then
            MISSING="$MISSING\n  - secrets.GH_CLIENT_ID"
          fi
          if [ -z "${{ secrets.GH_CLIENT_SECRET }}" ]; then
            MISSING="$MISSING\n  - secrets.GH_CLIENT_SECRET"
          fi
          if [ -z "${{ secrets.GH_APP_ID }}" ]; then
            MISSING="$MISSING\n  - secrets.GH_APP_ID"
          fi
          if [ -z "${{ secrets.GH_APP_PRIVATE_KEY }}" ]; then
            MISSING="$MISSING\n  - secrets.GH_APP_PRIVATE_KEY"
          fi
          if [ -z "${{ secrets.GH_APP_SLUG }}" ]; then
            MISSING="$MISSING\n  - secrets.GH_APP_SLUG"
          fi

          if [ -n "$MISSING" ]; then
            echo "::error::Missing required configuration in GitHub Environment 'production':$MISSING"
            echo ""
            echo "## âŒ Missing Configuration" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The following configuration is required in the GitHub Environment 'production':" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo -e "$MISSING" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Setup Instructions" >> $GITHUB_STEP_SUMMARY
            echo "1. Go to **Settings â†’ Environments â†’ production**" >> $GITHUB_STEP_SUMMARY
            echo "2. Add the missing variables and secrets" >> $GITHUB_STEP_SUMMARY
            echo "3. Re-run this workflow" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "See [docs/guides/deployment-troubleshooting.md](../docs/guides/deployment-troubleshooting.md) for details." >> $GITHUB_STEP_SUMMARY
            echo "valid=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "âœ… All required configuration present"
          echo "valid=true" >> $GITHUB_OUTPUT

  deploy:
    name: Deploy to Cloudflare
    runs-on: ubuntu-latest
    needs: validate
    environment: production
    outputs:
      api_url: ${{ steps.output.outputs.api_url }}
      app_url: ${{ steps.output.outputs.app_url }}

    steps:
      # ========================================
      # Phase 0: Setup
      # ========================================
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Install Pulumi CLI
        uses: pulumi/actions@v5

      # ========================================
      # Phase 1: Infrastructure (Pulumi)
      # ========================================
      - name: Create Pulumi State Bucket (if not exists)
        run: |
          BUCKET_NAME="${{ vars.PULUMI_STATE_BUCKET || 'sam-pulumi-state' }}"

          # Create the R2 bucket for Pulumi state if it doesn't already exist
          if npx wrangler r2 bucket create $BUCKET_NAME 2>&1; then
            echo "âœ… Created R2 bucket: $BUCKET_NAME"
          else
            echo "âœ… R2 bucket already exists or was created: $BUCKET_NAME"
          fi
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}

      - name: Login to Pulumi R2 Backend
        run: |
          BUCKET_NAME="${{ vars.PULUMI_STATE_BUCKET || 'sam-pulumi-state' }}"
          R2_ENDPOINT="${{ secrets.CF_ACCOUNT_ID }}.r2.cloudflarestorage.com"
          pulumi login "s3://${BUCKET_NAME}?endpoint=${R2_ENDPOINT}&region=auto"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}

      - name: Select or Create Pulumi Stack
        id: pulumi-select
        working-directory: infra
        run: |
          STACK_NAME="prod"
          echo "stack_name=$STACK_NAME" >> $GITHUB_OUTPUT

          # Try to select existing stack, create if not exists
          pulumi stack select $STACK_NAME 2>/dev/null || pulumi stack init $STACK_NAME
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          PULUMI_CONFIG_PASSPHRASE: ${{ secrets.PULUMI_CONFIG_PASSPHRASE }}

      - name: Set Pulumi Configuration (Dry Run)
        if: ${{ inputs.dry_run == true }}
        working-directory: infra
        run: |
          pulumi config set cloudflareAccountId ${{ secrets.CF_ACCOUNT_ID }}
          pulumi config set cloudflareZoneId ${{ secrets.CF_ZONE_ID }}
          pulumi config set baseDomain ${{ vars.BASE_DOMAIN }}
          pulumi config set resourcePrefix ${{ vars.RESOURCE_PREFIX || 'sam' }}
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          PULUMI_CONFIG_PASSPHRASE: ${{ secrets.PULUMI_CONFIG_PASSPHRASE }}

      - name: Pulumi Preview
        if: ${{ inputs.dry_run == true }}
        working-directory: infra
        run: pulumi preview --diff
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          PULUMI_CONFIG_PASSPHRASE: ${{ secrets.PULUMI_CONFIG_PASSPHRASE }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN }}

      - name: Set Pulumi Configuration
        if: ${{ inputs.dry_run != true }}
        working-directory: infra
        run: |
          pulumi config set cloudflareAccountId ${{ secrets.CF_ACCOUNT_ID }}
          pulumi config set cloudflareZoneId ${{ secrets.CF_ZONE_ID }}
          pulumi config set baseDomain ${{ vars.BASE_DOMAIN }}
          pulumi config set resourcePrefix ${{ vars.RESOURCE_PREFIX || 'sam' }}
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          PULUMI_CONFIG_PASSPHRASE: ${{ secrets.PULUMI_CONFIG_PASSPHRASE }}

      - name: Pulumi Up
        if: ${{ inputs.dry_run != true }}
        working-directory: infra
        run: pulumi up --yes --skip-preview
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          PULUMI_CONFIG_PASSPHRASE: ${{ secrets.PULUMI_CONFIG_PASSPHRASE }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN }}

      # ========================================
      # Phase 2: Configuration
      # ========================================
      - name: Sync Pulumi Outputs to Wrangler
        if: ${{ inputs.dry_run != true }}
        run: pnpm tsx scripts/deploy/sync-wrangler-config.ts
        env:
          PULUMI_STACK: ${{ steps.pulumi-select.outputs.stack_name }}
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          PULUMI_CONFIG_PASSPHRASE: ${{ secrets.PULUMI_CONFIG_PASSPHRASE }}

      - name: Read Security Keys from Pulumi State
        id: pulumi_keys
        if: ${{ inputs.dry_run != true }}
        working-directory: infra
        run: |
          # Read security keys from Pulumi state (they persist automatically)
          # Use heredoc syntax for multi-line PEM keys

          echo "Reading encryption key..."
          ENCRYPTION_KEY=$(pulumi stack output encryptionKey --show-secrets 2>/dev/null || echo "")
          echo "encryption_key=$ENCRYPTION_KEY" >> $GITHUB_OUTPUT

          echo "Reading JWT private key..."
          JWT_PRIVATE_KEY=$(pulumi stack output jwtPrivateKey --show-secrets 2>/dev/null || echo "")
          DELIMITER="EOF_PRIVATE_$(date +%s)"
          echo "jwt_private_key<<$DELIMITER" >> $GITHUB_OUTPUT
          echo "$JWT_PRIVATE_KEY" >> $GITHUB_OUTPUT
          echo "$DELIMITER" >> $GITHUB_OUTPUT

          echo "Reading JWT public key..."
          JWT_PUBLIC_KEY=$(pulumi stack output jwtPublicKey --show-secrets 2>/dev/null || echo "")
          DELIMITER="EOF_PUBLIC_$(date +%s)"
          echo "jwt_public_key<<$DELIMITER" >> $GITHUB_OUTPUT
          echo "$JWT_PUBLIC_KEY" >> $GITHUB_OUTPUT
          echo "$DELIMITER" >> $GITHUB_OUTPUT

          echo "Security keys read from Pulumi state"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          PULUMI_CONFIG_PASSPHRASE: ${{ secrets.PULUMI_CONFIG_PASSPHRASE }}

      - name: Ensure workers.dev Subdomain
        if: ${{ inputs.dry_run != true }}
        run: |
          # Cron triggers require a workers.dev subdomain to be initialized.
          # This is idempotent â€” if already set, the API returns the existing subdomain.
          SUBDOMAIN="${{ vars.RESOURCE_PREFIX || 'sam' }}"
          echo "Ensuring workers.dev subdomain is initialized: ${SUBDOMAIN}.workers.dev"

          RESPONSE=$(curl -s -w "\n%{http_code}" -X PUT \
            "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CF_ACCOUNT_ID }}/workers/subdomain" \
            -H "Authorization: Bearer ${{ secrets.CF_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "{\"subdomain\": \"${SUBDOMAIN}\"}")

          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo "workers.dev subdomain ready: ${SUBDOMAIN}.workers.dev"
          elif [ "$HTTP_CODE" -eq 409 ]; then
            echo "workers.dev subdomain already configured (OK)"
          else
            echo "::warning::Failed to set workers.dev subdomain (HTTP ${HTTP_CODE}): ${BODY}"
            echo "Cron triggers may not work. Initialize manually: CF Dashboard > Workers & Pages > Settings > Domains & Routes"
          fi

      # ========================================
      # Phase 3: Application (Wrangler)
      # ========================================
      - name: Build Applications
        if: ${{ inputs.dry_run != true }}
        run: pnpm build
        env:
          VITE_API_URL: https://api.${{ vars.BASE_DOMAIN }}

      - name: Deploy API Worker
        if: ${{ inputs.dry_run != true }}
        run: pnpm --filter @simple-agent-manager/api exec wrangler deploy --env production
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN }}

      - name: Deploy Web UI
        if: ${{ inputs.dry_run != true }}
        run: |
          PROJECT_NAME="${{ vars.RESOURCE_PREFIX || 'sam' }}-web-prod"
          pnpm --filter @simple-agent-manager/web exec wrangler pages deploy dist --project-name $PROJECT_NAME
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}

      - name: Run Database Migrations
        if: ${{ inputs.dry_run != true }}
        working-directory: infra
        run: |
          DB_NAME=$(pulumi stack output d1DatabaseName)
          cd ../apps/api
          pnpm exec wrangler d1 migrations apply $DB_NAME --remote --env production
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          PULUMI_CONFIG_PASSPHRASE: ${{ secrets.PULUMI_CONFIG_PASSPHRASE }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN }}

      - name: Configure Worker Secrets
        if: ${{ inputs.dry_run != true }}
        run: bash scripts/deploy/configure-secrets.sh production
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
          CF_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
          CF_ZONE_ID: ${{ secrets.CF_ZONE_ID }}
          GH_CLIENT_ID: ${{ secrets.GH_CLIENT_ID }}
          GH_CLIENT_SECRET: ${{ secrets.GH_CLIENT_SECRET }}
          GH_APP_ID: ${{ secrets.GH_APP_ID }}
          GH_APP_PRIVATE_KEY: ${{ secrets.GH_APP_PRIVATE_KEY }}
          GH_APP_SLUG: ${{ secrets.GH_APP_SLUG }}
          # Security keys from Pulumi state (primary source, persists automatically)
          PULUMI_ENCRYPTION_KEY: ${{ steps.pulumi_keys.outputs.encryption_key }}
          PULUMI_JWT_PRIVATE_KEY: ${{ steps.pulumi_keys.outputs.jwt_private_key }}
          PULUMI_JWT_PUBLIC_KEY: ${{ steps.pulumi_keys.outputs.jwt_public_key }}
          # GitHub secrets (backwards compatibility for existing deployments)
          SECRET_ENCRYPTION_KEY: ${{ secrets.ENCRYPTION_KEY }}
          SECRET_JWT_PRIVATE_KEY: ${{ secrets.JWT_PRIVATE_KEY }}
          SECRET_JWT_PUBLIC_KEY: ${{ secrets.JWT_PUBLIC_KEY }}

      # ========================================
      # Phase 4: VM Agent
      # ========================================
      - name: Setup Go
        if: ${{ inputs.dry_run != true && inputs.skip_agent != true }}
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Build VM Agent
        if: ${{ inputs.dry_run != true && inputs.skip_agent != true }}
        run: make -C packages/vm-agent build-all

      - name: Upload VM Agent Binaries
        if: ${{ inputs.dry_run != true && inputs.skip_agent != true }}
        working-directory: infra
        run: |
          R2_BUCKET=$(pulumi stack output r2Name)
          cd ..
          pnpm --filter @simple-agent-manager/api exec wrangler r2 object put $R2_BUCKET/agents/vm-agent-linux-amd64 --file packages/vm-agent/bin/vm-agent-linux-amd64
          pnpm --filter @simple-agent-manager/api exec wrangler r2 object put $R2_BUCKET/agents/vm-agent-linux-arm64 --file packages/vm-agent/bin/vm-agent-linux-arm64
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          PULUMI_CONFIG_PASSPHRASE: ${{ secrets.PULUMI_CONFIG_PASSPHRASE }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN }}

      # ========================================
      # Phase 5: Validation
      # ========================================
      - name: Health Check
        if: ${{ inputs.dry_run != true }}
        run: |
          API_URL="https://api.${{ vars.BASE_DOMAIN }}"
          echo "Waiting for API to be ready at $API_URL..."

          for i in {1..30}; do
            if curl -sf "$API_URL/health" > /dev/null 2>&1; then
              echo "âœ… API is healthy"
              exit 0
            fi
            echo "Waiting for API... ($i/30)"
            sleep 10
          done

          echo "âŒ Health check timed out"
          exit 1

      - name: Output Deployment URLs
        id: output
        if: ${{ inputs.dry_run != true }}
        run: |
          echo "api_url=https://api.${{ vars.BASE_DOMAIN }}" >> $GITHUB_OUTPUT
          echo "app_url=https://app.${{ vars.BASE_DOMAIN }}" >> $GITHUB_OUTPUT

      # ========================================
      # Job Summary
      # ========================================
      - name: Write Job Summary
        if: always()
        run: |
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "## Pulumi Preview Complete ðŸ”" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "This was a **dry run**. No changes were applied." >> $GITHUB_STEP_SUMMARY
          elif [ "${{ job.status }}" = "success" ]; then
            echo "## Deployment Complete! ðŸš€" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Commit:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
            echo "**Base Domain:** ${{ vars.BASE_DOMAIN }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Access URLs" >> $GITHUB_STEP_SUMMARY
            echo "- **API:** https://api.${{ vars.BASE_DOMAIN }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Web UI:** https://app.${{ vars.BASE_DOMAIN }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### What Was Deployed" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Infrastructure (Pulumi): D1, KV, R2, DNS" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… API Worker" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Web UI (Pages)" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Database migrations" >> $GITHUB_STEP_SUMMARY
            if [ "${{ inputs.skip_agent }}" != "true" ]; then
              echo "- âœ… VM Agent binaries" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "## Deployment Failed âŒ" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Commit:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Check the logs above for error details." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Security Keys Status
        if: ${{ inputs.dry_run != true }}
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ” Security Keys" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ secrets.ENCRYPTION_KEY }}" ]; then
            echo "Using keys from **GitHub Secrets** (backwards compatibility mode)." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "To migrate to automatic persistence via Pulumi state:" >> $GITHUB_STEP_SUMMARY
            echo "1. Delete \`ENCRYPTION_KEY\`, \`JWT_PRIVATE_KEY\`, \`JWT_PUBLIC_KEY\` from GitHub Secrets" >> $GITHUB_STEP_SUMMARY
            echo "2. Re-deploy to use Pulumi-managed keys" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "âš ï¸ **Note:** Migration creates new keys, invalidating existing encrypted data." >> $GITHUB_STEP_SUMMARY
          else
            echo "Keys managed by **Pulumi state** - no manual persistence needed." >> $GITHUB_STEP_SUMMARY
          fi
